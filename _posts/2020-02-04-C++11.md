---
layout:     post
title:      "C++11新特性之《C++ Primer》学习笔记"
subtitle:   "C++学习笔记 三"
date:       2020-02-04
author:     "Felix"
header-img: "img/in-post/2020-02-04-C++11/bg.jpg"
catalog: true
tags:
   - C++
---

# C++11的新特性



## 一、防止继承的发生——final关键字

final关键字能让我们设计出一种类，使得其他类不能作他的继承，就像final这个词的名字所代表的名字一样。为了实现这一目的，C++11支持我们在类的名字后面加上此关键字

~~~c++
class NoDerived final {/* ... */};	//NoDerived不能作为基类继承。
class Base {/* ... */};							
class Last final : Base {/* ... */};	//Last 不能作为基类
class Bad : NoDerived {/* ... */}; 	//错误，NoDerived不能作为基类
class Bad2 : NoDerived {/* ... */}	//错误，Last也是final的。
~~~

## 二、默认构造函数—— = default关键字

在类中，如果没有任何构造函数被定义，编译器会为类创建一个没有任何参数的默认构造函数（default constructor）。当有参数的构造函数被显式地定义了以后，除非人为的添加默认构造函数，否则系统不会再为类创建默认构造函数。C++11新特性为我们提供了= default关键字，使我们在需要默认的行为时来要求编译器生成默认构造函数。其中，= default可以和声明一起出现在类的__内部__，作为__内联函数__存在；也可以在类的外部，则该成员函数默认情况下不是内联的。

~~~c++
class MyClass
{
	public:
			MyClass() = default;
  		MyClass(const std::string &s) : myString(s) { }
  		MyClass(const std::string &s, unsigned n, double p) : 
  				myString(s), unit(n), revenue(p*n) { }
  private:
  		std::string myString;
  		unsigned unit;
  		double revenue;
}
~~~

关于默认构造函数的说明：

编译器自动生成的默认构造函数又叫合成的默认构造函数(synthesized default constructor)，一般情况下应当人为的创建自定义构造函数，原因如下：

* 默认构造函数只适合非常简单的类。
* 默认构造函数可能会带来某些隐晦的错误，如某些定义在块内的书组合指针的对象被默认初始化，则他们的值将是未定义的。
* 如果一个类的成员内有其他类的对象，只有当成员对象的类存在默认构造函数时，这个类的默认构造函数才会被创建成功。

> 一般情况下，如果一个类在某些情况下需要控制对象的初始化，那么该类很有可能在所有情况下都需要控制对象的初始化。

## 三、