---
layout:     post
title:      "C++11新特性"
subtitle:   "C++学习笔记 三"
date:       2020-02-04
author:     "Felix"
header-img: "img/in-post/2020-02-04-C++11/bg.jpg"
catalog: true
tags:
   - C++
---

# C++11 的新特性

## 一、防止继承的发生—— final 关键字

final关键字能让我们设计出一种类，使得其他类不能作他的继承，就像final这个词的名字所代表的名字一样。为了实现这一目的，C++11支持我们在类的名字后面加上此关键字

~~~c++
class NoDerived final {/* ... */};	//NoDerived不能作为基类继承。
class Base {/* ... */};							
class Last final : Base {/* ... */};	//Last 不能作为基类
class Bad : NoDerived {/* ... */}; 	//错误，NoDerived不能作为基类
class Bad2 : NoDerived {/* ... */}	//错误，Last也是final的。
~~~

## 二、默认构造函数—— = default 关键字

在类中，如果没有任何构造函数被定义，编译器会为类创建一个没有任何参数的默认构造函数（default constructor）。当有参数的构造函数被显式地定义了以后，除非人为的添加默认构造函数，否则系统不会再为类创建默认构造函数。C++11新特性为我们提供了= default关键字，使我们在需要默认的行为时来要求编译器生成默认构造函数。其中，= default可以和声明一起出现在类的__内部__，作为__内联函数__存在；也可以在类的外部，则该成员函数默认情况下不是内联的。

~~~c++
class MyClass
{
	public:
			MyClass() = default;
  		MyClass(const std::string &s) : myString(s) { }
  		MyClass(const std::string &s, unsigned n, double p) : 
  				myString(s), unit(n), revenue(p*n) { }
  private:
  		std::string myString;
  		unsigned unit;
  		double revenue;
}
~~~

关于默认构造函数的说明：

编译器自动生成的默认构造函数又叫合成的默认构造函数(synthesized default constructor)，一般情况下应当人为的创建自定义构造函数，原因如下：

* 默认构造函数只适合非常简单的类。
* 默认构造函数可能会带来某些隐晦的错误，如某些定义在块内的书组合指针的对象被默认初始化，则他们的值将是未定义的。
* 如果一个类的成员内有其他类的对象，只有当成员对象的类存在默认构造函数时，这个类的默认构造函数才会被创建成功。

> 一般情况下，如果一个类在某些情况下需要控制对象的初始化，那么该类很有可能在所有情况下都需要控制对象的初始化。

## 三、标准库函数 begin 和 end

新标准引入了两个名为 begin 和 end 的函数，于容器中的两个同名函数功能类似，将数组作为成员参数。

~~~C++
int ia[] = {0,1,2,3,4};
int *beg = begin(ia);	//指向ia的首元素
int *last = end(ia)； //指向ia的尾元素后一元素
~~~

这两个函数定义在 iterator 头文件中。可以使用这两个函数轻易地写出一个循环处理数组中的元素。如:

~~~C++
//找到数组中第一个负数
int *pbeg = begin(arr), *pend = end(arr);
while (pgeb != pend && *pbeg > 0)
{
  ++pbeg;	
}
~~~

同时我们可以用他们来通过数组初始化 vector ：

~~~C++
int arr[] = {1, 2, 3, 4, 5};
vector<int> ivec(begin(arr), end(arr));
~~~

## 四、auto 和 decltype

## 五、lambda 表达式

## 六、范围for语句

这种 for 语句可以遍历容器或其他序列的所有元素，其语法形式为

~~~C++
for (declaration : expression)
  statement
~~~

其中，expression 表示的必须是一个序列，比如用花括号括起来的参数值列表(vector< string > articles = {"s", "ss"};)、数组、或者容器类型。他们的共同特点是拥有能返回迭代器的 begin 和 end 成员。

declaration 定义一个变量，序列每个元素都能转换成该变量的类型，最简单的方法是使用 auto类型说明符，这个关键字可以令编译器帮助我们指定合适的类型，**如果需要对序列中的元素执行写操作，循环变量必须声明为引用类型**。

例如：

~~~C++
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt];	//12个未初始化的元素
for(size_t i = 0; i != rowCnt; i++)
  for(size_t j = 0; j != colCnt; j++)
  {
    	ia[i][j] = i * colCnt + j;
  }
~~~

代码可简写为:

~~~C++
size_t cnt = 0;
for(auto &row : ia)
    for(auto &col : row)
    {
        col = cnt;
        cnt++;
    }
~~~

上例，因为要改变索引的值，所以把控制变量 row 和 col 都声明为引用。如果不使用引用，那么上例 row 就会被转换为指针，而 col 就即将在一个 int* 类型中遍历，这是不合法的。

> 在使用范围 for 语句处理多维数组时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

## 七、别名声明 using

传统方法使用 typedef 来定义类型的别名。 新标准规定了一种新方法，使用别名声明（alias declaration）来定义类型的别名。

~~~C++
using SI = Sales_item;
~~~

这种方法用关键字 using 作为别名声明的开始，使其紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。

## 八、使用 sizeof 来获取类成员的大小

通常情况下只能通过类的对象来访问类的成员，但是sizeof运算符无需我们提供一个具体的对象，因为要想知道类成员的大小无需真的获取该成员。

## 九、 auto 尾置返回类型

再遇到诸如返回数组指针的函数时，返回类型造成函数的定义或声明很难写出，如in (*func(int i)) [10]之类的，可以使用尾置返回类型。任何函数的定义都能使用尾置返回，比如返回的是数组的指针或者数组的引用。尾置返回类型在兴安列表后边并以一个 ->符号开头，为了表示函数真正的返回类型在星灿烈表之后，在本应该出现返回类型的地方放置一个auto。