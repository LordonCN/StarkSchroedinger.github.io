---
layout:     post
title:      "C++细碎知识点汇总"
subtitle:   "C++学习笔记 一"
date:       2020-01-22
author:     "Felix Zhang"
header-img: "img/in-post/2020-01-03-C++-Notes/bg.jpg"
catalog: true
tags:
   - C++


---

# C++中的细碎知识点汇总

## 一、C++中static的作用

static表示静止，静态。下面是常见应用。

1. 作用于函数内部的局部变量

   局部作用于静态变量的特点：当一个函数返回后，下一次再调用时，该变量还会保持上一回的值，函数内部的静态变量只开辟一次空间，且不会因为多次调用而产生副本，也不会因为函数返回而失效。普通局部变量如果未赋初值就使用，编译器会报错；静态变量会被默认初始化，如int初始化为0。

2. 作用于类的成员，解决同一个类不同对象之间函数共享与数据共享的问题。

   作用于类的数据成员，使其成为静态数据成员。__静态成员在每一个类中只有一个副本__，该类所有对象共同维护和使用该成员。需要注意的是：

   * 访问静态数据成员的方式为 __类名::标识符__。

     之所以采用这样的访问方式，是因为静态数据成员不属于任何一个对象。

   * 静态数据成员的初始化应在__类定义外__进行。

     在类外进行定义是因为需要以这种方式专门为他们分配空间。

   静态成员函数就是使用static关键字声明的函数成员，同静态数据成员一样，静态函数成员函数也属于整个类，由该类所有对象共同所有，为所有对象共享。

   * 静态成员函数主要用于处理该类的静态数据成员，可以直接调用静态数据成员。如果访问非静态数据，则需要通过对象来访问，且这个对象**应是函数的参数**。
   * 如果在类外调用静态成员函数，贼使用__类名::函数名__调用，也可使用类名.函数名调用。

   ~~~C++
   class MyObject
   {
     	public:
     	explicit MyObject() : val(0), name("") {count++;}
     	explicit MyObject(const int value): val(value) {
         	count++;
       }
     	explicit MyObject(const int value, const std::string myName): val(value), name(myName) 			{
       		count++;  
       }
     	MyObject(const MyObject& my)
       {
         	this->val = my->val;
         	this->name = my->name;
       }
     	static int count;		//如果不赋初值则会默认为0
     	static void DisplayCount(MyObject* moj)
       {
         	std::cout << count << endl;
       }
     	private:
     	int val;
     	std::string name;
   };
   
   int MyObject::count = 0;		//静态数据成员声明的定义和初始化。
   int main()
   {
     	MyObject::DisplayCount();
     	MyObject obj1(0, "Table");
     	MyObject::DisplayCount();
     	MyObject *obj2 = new MyObject();
     	DisplayCount();
     	delete obj2;
     	return 0;
   }
   ~~~

   

## 二、struct与class定义类的区别

使用class与struct都可以定义类，这两种方式仅仅是形式上有所不同，唯一的区别在于，struct和class的默认访问权限不太一样。类可以在他的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于定义类的方式（使用struct还是class）。

* 如果使用struct定义类，那么第一个访问说明符之前的成员是public。
* 如果使用class定义类，那么第一个访问说明符之前的成员是private。

> 出于统一编程风格的考虑，当我们希望定义的类的所有成员全是public时，才使用struct。

## 三、const修饰类的成员

### 1. const成员函数

const修饰类的成员函数不能对类的任何成员进行更改。const在这种情况下实际上是修饰该成员函数的第一个隐藏参数——this指针，类似于`const MyClass* const this`，this指针指向该成员函数的对象不能更改，同时this指针所指向的所有内容也不能更改。

* const对象只能调用const成员函数，而不能调用非const成员函数。

  这是因为const对象的this指针是` const MyClass* const this`结构，而非const成员函数的第一个隐藏形参类型是` MyClass* const this`类型，前者不能隐式转换为后者，但是后者可以隐式转换为前者，这也是下一条规则成立的原因。

* 非const对象可以调用const成员函数。

### 2. const成员数据

const数据成员必须在构造函数初始化列表中初始化，而不能在构造函数体内初始化。

### 3. const static 数据成员

参见 <https://starkschoredinger.github.io> 条款二。

## 四、string的细碎知识点
1. 使用getline和cin给string对象赋值，前者原封不动地将所有字符赋值到string中，但cin会忽略第一个非空格字符之前的空格以及最后 一个非空格字符末尾的空格。
2. string包括其他标准库类型的size()都一样，返回的不是int，而是size_type类型的返回值，是一个无符号类型，所以如果使用size()和一个负数比较大小，一定是后者较大。

## 五、