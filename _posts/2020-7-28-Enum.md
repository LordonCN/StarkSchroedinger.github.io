---
layout:     post
title:      "强枚举到底右多强"
subtitle:   "C++学习笔记"
date:       2020-07-28
author:     "Felix Zhang"
header-img: "img/in-post/2020-01-31-LeetCode-Notes/bg.jpg"
catalog: true
tags:
   - C++
---
# 强枚举到底右多强

## 枚举无处不在

在工程代码当中，只要和数据打交道，基本上就离不开枚举类型——这是因为单纯的字符串类型在一份合格的工程代码中是不应该出现的，所有的字符串都应以枚举或常量的形式定义。举个例子，如果我们有一个图像类，其中有两个成员分别代表了该图像的类型和分辨率，那么如果写成以下形式，那就要再去看一下工程规范了。

~~~C++
// Image.h
// 定义
class Image{
private:
  	String imgType;
    int resolution;
public:
    Image();
    Image(String imgType, int resolution);
  
/**
 * 其他成员已省略...
**/
};

// Process.cpp
Image tmpImage = new Image("jpg"， 1920 * 1080)；
~~~

上边调用是危险的，准确的来说问题出现在Image类的定义处，没有对两个成员的初始化作强限制。例如第一个参数调用者可能将参数传为"JPG"，就意思表达来说是准确的，但是会给代码带来极大的不确定性；后者也可被传入诸如`1080 * 1920`之类的不符合要求的值，即使在备注上加上说明，也不能保证这是一个良好的设计。

以上所有的传参都应被常量或者枚举所替换，如对于图片的类型，我们可以设计一个枚举，从而存放可能需要的类型，而在类中成员，我们将其定义为枚举类型。

~~~C++
enum ImageType{
    JPG = 100,
    PNG = 200,
    TIFF = 300,
    SVG = 400
};

enum ImageResolution{
    HIGH = 1920 * 1080,
  	HIGH_2K = 2560 * 1440,
    HIGH_4K = 4096 * 2160
};

class Image{
private:
  	ImageType imgType;
    ImageResolution resolution;
public:
    Image();
    Image(String imgType, ImageResolution resolution);
  
/**
 * 其他成员已省略...
**/
};
~~~

请看几个问题。

首先，在上例中，传统枚举的写法允许你这样写：

~~~C++
Image tmpImage = new Image(ImageType::JPG， ImageResolution::HIGH_2K)；
~~~

但同时，他还允许你这样写：

~~~C++
Image tmpImage = new Image(JPG, HIGH_K);
~~~

在传统枚举中，枚举类型是**不限定作用域的(unscoped enumeration)**，枚举中的成员可不加命名空间限定符随意使用，但是**不限定作用域的做法总是充满危险的**，就上例而言，我们无法确定在当前命名空间是否还存在着与`ImageResolution`相对应的`CameraResolution`枚举类型，同样包含有成员`HIGH, HIGH_2K, HIGH_4K`中的一个或多个，若真的包含，很可能在不知觉中被调用者混淆——更让人难过的事，调用者可能并没有料到如此。因为传统枚举总是默认可以被**隐式地**转化为`int`类型，在不知不觉中就进行了跨作用域的类型转换。

说到隐式转换，这就不得不让人提到另一个让人心塞的问题。对于`int`类型所能表达的最大范围是`2147483647`，如果我们在显示得给枚举成员赋值时超出这个值呢？如：

~~~C++
enum annoyType{
    BIG_INTEGER = 2147483648;		// 这里会发生什么，会报错吗？
}
~~~

