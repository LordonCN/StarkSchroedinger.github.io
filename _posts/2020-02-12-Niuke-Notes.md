---
layout:     post
title:      "牛客网刷题笔记"
subtitle:   "面试题汇总 五"
date:       2020-02-12
author:     "Felix"
header-img: "img/in-post/2020-02-12-Niuke-Notes/bg.jpg"
catalog: true
tags:
   - Niuke



---

# 牛客网刷题笔记

* 关于输入输出

  string类型：`string s; getline(cin, s);`

  char类型：· char c; cin >> c;·

* 不稳定的排序算法有：希快选堆，分别希尔排序，快速排序，直接选择排序，堆排序

* 'int a = 10; char c = 'a';那么表达式` a + c + 4.32`的类型为？

  double，在表达式运算类型总是低等级往高等级转换。表达式的类型等级为：**char** < **short** < **int** < unsigned int < long < unsigned long < long long < unsigned long long < **float** < **double** < long double 不同类型运算结果类型向右边靠齐。无符号比有符号等级高。

* unsigned int 与 int 比大小？

  ~~~C++
cout << (unsigned int)(-1) > 1 ? 1 : 0;
  ~~~

  以上代码将返回1，而不是0；这与将int类型的-1转换为unsigned int有关。

  > 计算机中32位int类型变量的范围，其中int类型是带符号整数。
  >
  > 正数在计算机中表示为原码，**最高位为符号位**:
  >
> 1的原码为0000 0000 0000 0000 0000 0000 0000 0001
  >
> 2147483647的原码为0111 1111 1111 1111 1111 1111 1111 1111
  >
  > 所以最大的正整数是2147483647
  >
  > 负数在计算机中表示为**补码**，最高位为符号位：
  >
  > -1：
  >
  > 原码为1000 0000 0000 0000 0000 0000 0000 0001，
  >
  > 反码为1111 1111 1111 1111 1111 1111 1111 1110，
  >
  > 补码为1111 1111 1111 1111 1111 1111 1111 1111
  >
  > -2147483647：
  >
  > 原码为1111 1111 1111 1111 1111 1111 1111 1111，
  >
  > 反码为1000 0000 0000 0000 0000 0000 0000 0000，
  >
  > 补码为1000 0000 0000 0000 0000 0000 0000 0001
  >
  > 所以最小的负数是-2147483647吗？错，不是。
  >
  > 在二进制中，0有两种表方法。
  >
  > +0的原码为0000 0000 0000 0000 0000 0000 0000 0000，
  >
  > -0的原码为1000 0000 0000 0000 0000 0000 0000 0000，
  >
  > 因为0只需要一个，所以把-0拿来当做一个最小的数-2147483648。
  >
  > -2147483648的补码表示为1000 0000 0000 0000 0000 0000 0000 0000，在32位没有原码。
  >
  > 注意，这个补码并不是真正的补码，真正的补码是1 1000 0000 0000 0000 0000 0000 0000 0000，溢出。
  >
  > 所以带符号32位int类型整数为-2147483648~2147483647
  
  
  

> 最后更新日期：2020-02-12