---
layout:     post
title:      "读书笔记——我来重述《Effective C++》"
subtitle:   "C++学习笔记"
date:       2020-12-31
author:     "Felix Zhang"
header-img: "img/in-post/2020-12-31-Effective-C++/bg.jpg"
catalog: true
tags:
   - C++	
   - Effective C++
---

> Spoiler alert! This is gonna be a long long blog.

## 我为什么写这篇BLOG

我动手写这篇博文——或者说总结——的想法已经很久了，《Effective C++》这本书的作者和译者都是C++大师，这篇著作有也已享誉全球很多年。但是书无完书、人无完人，这本书也因为这样或那样的原因（我更愿称之为引起我不适的问题）让我有必要为此写一篇总结，使得这篇总结更像《Effective C++》对应的__工具书版本__，帮助我在未来想要回顾某一条款的内容时，最大限度地节约我的时间。如果没有读过这本书的读者因为翻译或者是其他问题没有耐心再读下去的时候，不妨也看看这篇文章，我会从一个中国人的逻辑角度，使用大陆人的语言习惯（原译者是中国台湾同胞），尽可能直接并清楚得涵盖每一个条款最重要的知识点，让你在最短的时间抓住核心，再逐个击破各个问题。我并不觉得这篇文章可以就此替代《Effective C++》，其实是远远不够，我并不会在文章中涵盖太多的代码和细节，如果你想要探究每一个细节，请拿起原著，乖乖把每一页看完。

首先，我想说一说这本书让我不适的地方：

1. 内容有点老旧。这本书没有涵盖C++11，可以说，有了更高版本的编译器，许多条款使用C++98解决问题的思路和方式都显得有些冗余了，我会在每一条款的总结中直接指出在更高版本C++下的解决方案，出于个人的见解，书中提出的解决问题的方法就可以淘汰了，这些地方包括但不限于`final, override, shared_ptr, = delete`。
2. 翻译僵硬。这并不能怪侯捷，因为面对一个大师的作品，我们肯定要在保留语言的原汁原味和尽量符合各国读者的语言风格面前摇摆取舍，但这也造成了“在这个故事结束之前”，“那就进入某某某变奏曲了”这种相当英文的表达出现在了文中，让不太熟悉英文的读者感到莫名其妙——”变奏曲在哪？“。说实在话，就是知道他们英文原文的我读起他们翻译也觉得怪怪的。因此在我的总结中，各种因果关系我会把舌头捋直了说，毕竟我不是大师，我只注重效率就可以了。
3. 作者的行文之风让这本书的读者必须以读一本小说的心态去拜读这部著作。在了解每一个条款时，作者精心准备了各种玩笑、名人名言、典故以及例子，尽量让你感觉不到教科书般的迂腐之气，也用了俏皮的语言使授课不那么僵硬（尽管翻译还是让他僵硬了起来）。但对于第二甚至是第三次读这本书的我来说，我更希望这本书像一本__工具书__。例如某条款解决了一个问题，在第一遍读的时候我重点去体会解决这种问题的__方法是什么__，第二遍我可能更想知道这种问题在什么情况下可能会发生——__什么时候去用__，这是我最关心的。不幸的是，出现这一问题的三个场景可能分布在这个条款的角角落落，我必须重新去读一遍那些已经不好笑的笑话，才能把他们整理好。所以，这篇博文替我把上述我在翻阅时更care的内容总结起来，争取两分钟可以把一个条款的纲要回忆起来，这便是这个博文的目的。

最后，再次向Meyers和侯捷大师致敬。

## 六、继承与面对对象设计

当你设计一个与继承有关的类时，需要考虑的事情有很多：

* 什么类型的继承？
* 接口是虚函数还是非虚的？
* 缺省参数如何设计？

想要思考得出以上问题的合理答案，需要考虑的事情就更多了：各种类型的继承到底意味着什么？虚函数的本质需求是什么？继承会影响名称查找吗？虚函数是否是必须的呢？有哪些替代选择？这些问题都在本章做出解答。

### 条款32：确定你的public继承保证了is-a关系

public继承的意思是：__子类是一种特殊的父类__，这就是所谓的“is-a”关系。但是本条款指出了其更深层次的意义：在使用public继承时，__子类必须涵盖父类的所有特点，必须无条件继承父类的所有特性和接口__。之所以单独指出这一点，是因为如果单纯偏信生活经验，会犯错误。

比如鸵鸟是不是鸟这个问题，如果我们考虑飞行这一特性（或接口），那么鸵鸟类在继承中就绝对不能用public继承鸟类，因为鸵鸟不会飞，我们要在**编译阶段消除调用飞行接口的可能性**；但如果我们关心的接口是下蛋的话，按照我们的法则，鸵鸟类就可以public继承鸟类。同样的道理，面对矩形和正方形，生活经验告诉我们正方形是特殊的矩形，但这并不意味着在代码中二者可以存在public的继承关系，矩形具有长和宽两个变量，但正方形无法拥有这两个变量——没有语法层面可以保证二者永远相等，那就不要用public继承。

所以在确定是否需要public继承的时候，我们首先要搞清楚**子类是否必须拥有父类每一个特性**，如果不是，则无论生活经验是什么，都不能视作"is-a"的关系。__public继承关系不会使父类的特性或接口在子类中退化，只会使其扩充。__

### 条款33: 避免遮掩继承而来的名称

这个条款研究的是继承中多次重载的虚函数的**名称遮盖问题**，如果在你设计的类中没有涉及到对同名虚函数做多次重载，请忽略本条款。

在父类中，虚函数`foo()`被重载了两次，可能是由于参数类型重载（`foo(int)`），也可能是由于`const`属性重载(`foo() const`)。如果子类仅对父类中的`foo()`进行了覆写，那么在子类中父类的另外两个实现(`foo(int)` ,`foo() const`)也无法被调用，这就是名称遮盖问题——名称在**作用域级别的遮盖是和参数类型以及是否虚函数无关的**，即使子类重载了父类的一个同名，父类的所有同名函数在子类中都被遮盖，个人觉得是比较反直觉的一点。

如果想要重启父类中的函数名称，需要在子类有此需求的作用域中（可能是某成员函数中，可能是public 或private内）加上`using Base::foo;`，即可把父类作用域汇总的同名函数拉到目标作用域中，需要注意的是，此时父类中的`foo(int)`和`foo() const`都会被置为可用。

如果只想把父类某个在子类中某一个已经不可见的同名函数复用，可使用inline forwarding function。

### 条款34：区分接口继承和实现继承

我们在条款32讨论了public继承的实际意义，我们在本条款将明确在public继承体系中，不同类型的接口——纯虚函数、虚函数和非虚函数——**背后隐藏的设计逻辑**。

首先需要明确的是，成员函数的接口总是会被继承，而public继承保证了，如果某个函数可施加在父类上，那么他一定能够被施加在子类上。不同类型的函数代表了**父类对子类实现过程中不同的期望**。

* 在父类中声明纯虚函数，是为了**强制子类拥有一个接口**，并**强制子类提供一份实现**。
* 在父类中声明虚函数，是为了**强制子类拥有一个接口**，并**为其提供一份缺省实现**。
* 在父类中声明非虚函数，是为了**强制子类拥有一个接口以及规定好的实现**，并不允许子类对其做任何更改（条款36要求我们不得覆写父类的非虚函数）。

在这其中，有可能出现问题的是普通虚函数，这是因为父类的缺省实现并不能保证对所有子类都适用，因而当子类忘记实现某个本应有定制版本的虚函数时，父类应从__代码层面提醒子类的设计者做相应的检查__，很可惜，普通虚函数无法实现这个功能。一种解决方案是，在父类中**为纯虚函数提供一份实现**，作为需要主动获取的缺省实现，当子类在实现纯虚函数时，检查后明确缺省实现可以复用，则只需调用该缺省实现即可，这个主动调用过程就是在代码层面提醒子类设计者去检查缺省实现的适用性。

从这里我们可以看出，将纯虚函数、虚函数区分开的并不是在父类有没有实现——纯虚函数也可以有实现，其二者本质区别在于父类对子类的要求不同，前者在于**从编译层面提醒子类主动实现接口**，后者则侧重于**给予子类自由度对接口做个性化适配**。非虚函数则没有给予子类任何自由度，而是要求子类坚定的遵循父类的意志，**保证所有继承体系内能有其一份实现**。

### 条款35：考虑virtual函数以外的其他选择



### 条款36：绝不重新定义继承而来的non-virtual函数

意思就是，如果你的函数有多态调用的需求，一定记得把它设为虚函数，否则在动态调用（基类指针指向子类对象）的时候是不会调用到子类重载过的函数的，很可能会出错。

反之同理，如果一个函数父类没有设置为虚函数，如果有多态需求，你千万千万不要在子类重载它，也会犯上边类似的错误。

理由就是，多态的动态调用中，只有虚函数是动态绑定，非虚函数是静态绑定的——指针（或引用）的静态类型是什么，就调用那个类型的函数，和动态类型无关。

话说回来，虚函数的意思是“__接口一定被继承，但实现可以改__”，而非虚函数的意思是“__接口和实现都必须被继承__”，这就是“虚”的实际意义。

### 条款37：绝不重新定义继承而来的缺省参数值

这个条款包含双重意义，在继承中：

1. 不要更改父类非虚函数的缺省参数值，其实**不要重载父类非虚函数的任何东西**，不要做任何改变！
2. 虚函数不要写缺省参数值，子类自然也不要改，**虚函数要从始至终保持没有缺省参数值**。

第一条在条款36解释过了，第二条的原因在于，缺省参数值是属于__静态绑定__的，而虚函数属于动态绑定。虚函数在大多数情况是供动态调用，而在动态调用中，子类做出的缺省参数改变其实并没有生效，反而会引起误会，让调用者误以为生效了。

缺省参数值属于静态绑定的原因是为了提高运行时效率。

如果你真的想让某一个虚函数在这个类中拥有缺省参数，那么就把这个虚函数设置成private，在public接口中重制非虚函数，让非虚函数这个“外壳”拥有缺省参数值，当然，这个外壳也是一次性的——在被继承后不要被重载。

### 条款38：通过复合塑膜出has-a关系，或“根据某物实现出”

两个类的关系除了继承之外，还有“一个类的对象可以作为另一个类的成员”，我们称这种关系为“类的复合”，这个条款解释什么情况下我们应该用类的复合。

第一种情况，非常简单，说明某一个类“拥有”另一个类对象作为一个属性，比如学生拥有铅笔、市民拥有身份证等，不会出错。

第二种情况被讨论的更多，即“一个类根据另一个类实现”。比如“用stack实现一个queue”，更复杂一点的情况可能是“用一个老版本的Google Chrome内核去实现一个红芯浏览器”。

这里重点需要区分第二种情形和public继承中提到的"is-a"的关系。请牢记“is-a”关系的唯一判断法则，一个类的全部属性和接口是否必须**全部**继承到另一个类当中？另一方面，“用一个工具类去实现另一个类”这种情况，是需要对工具类进行**隐藏**的，比如人们并不关心你使用stack实现的queue，所以就藏好所有stack的接口，只把queue的接口提供给人们用就好了，而红芯浏览器的开发者自然也不希望人们发现Google Chrome的内核作为底层实现工具，也需要“藏起来”的行为。

### 条款39：明智而审慎地使用private继承

与类的复合关系相似，private继承正是表达“__通过某工具类实现另一个类__”。那么相似的，工具类在目标类中自然应该被隐藏——所有接口和变量都不应对外暴露出来。这也解释了private继承的内涵，它本质是一种__技术封装__，和public继承不同的是，private继承表达的是“__只有实现部分被继承，而接口部分应略去__”的思想。

与private继承的内涵相对应，在private继承下，__父类的所有成员都转为子类私有变量__——不提供对外访问的权限，外界也无需关心子类内有关父类的任何细节。

当我们拥有“用一个类去实现另一个类”的需求的时候，如何在类的复合与private继承中做选择呢？

* 尽可能用复合，除非必要，不要采用private继承。
* 当我们需要对工具类的某些方法（虚函数）做重载时，我们应选择private继承，这些方法一般都是工具类内专门为继承而设计的调用或回调接口，需要用户自行定制实现。

如果使用private继承，我们无法防止当前子类覆写后的虚函数被它的子类继续覆写，这种要求类似于对__某个接口（函数）加上关键字final一样__。为了实现对目标类的方法的防覆写保护，我们的做法是，在目标类中声明一私有嵌套类，该嵌套类public继承工具类，并在嵌套类的实现中覆写工具类的方法。

~~~C++
class TargetClass {							//目标类
private:
		class ToolHelperClass : public ToolClass {		//嵌套类，public继承工具类
    public:
        void someMethod() override;								//本应被目标类覆写的方法在嵌套类中实现，这样TargetClass的子类就无法覆写该方法。
    }  
}
~~~

如此以来，目标类的子类就无法再次覆写我们想要保护的核心方法。

### 条款40：明智而审慎地使用多继承

原则上不提倡使用多继承，因为多继承可能会引起多父类共用父类，导致在底层子类中出现多余一份的共同祖先类的拷贝。为了避免这个问题C++引入了**虚继承**，但是虚继承会使子类对象变大，同时使成员数据访问速度变慢，这些都是虚继承应该付出的代价。

在不得不使用多继承时，请慎重地设计类别，尽量不要出现菱形多重继承结构（“B、C类继承自A类，D类又继承自B、C类”），即尽可能地避免虚继承，一个完好的多继承结构不应在事后被修改。虚基类中应尽可能避免存放数据。