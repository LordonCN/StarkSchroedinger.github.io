---
layout:     post
title:      "读书笔记——我来重述《Effective C++》"
subtitle:   "C++学习笔记"
date:       2020-12-31
author:     "Felix Zhang"
header-img: "img/in-post/2020-12-31-Effective-C++/bg.JPG"
catalog: true
tags:
   - C++	
   - Effective C++
---

> Spoiler alert! This is gonna be a long long blog.

## 我为什么写这篇BLOG

我动手写这篇博文——或者说总结——的想法已经很久了，《Effective C++》这本书的作者和译者都是C++大师，这篇著作有也已享誉全球很多年。但是书无完书、人无完人，这本书也因为这样或那样的原因（我更愿称之为引起我不适的问题）让我有必要为此写一篇总结，使得这篇总结更像《Effective C++》对应的**工具书版本**，帮助我在未来想要回顾某一条款的内容时，最大限度地节约我的时间。如果没有读过这本书的读者因为翻译或者是其他问题没有耐心再读下去的时候，不妨也看看这篇文章，我会从一个中国人的逻辑角度，使用大陆人的语言习惯（原译者是中国台湾同胞），尽可能直接并清楚得涵盖每一个条款最重要的知识点，让你在最短的时间抓住核心，再逐个击破各个问题。我并不觉得这篇文章可以就此替代《Effective C++》，其实是远远不够，我并不会在文章中涵盖太多的代码和细节，如果你想要探究每一个细节，请拿起原著，乖乖把每一页看完。

首先，我想说一说这本书让我不适的地方：

1. 内容有点老旧。这本书没有涵盖C++11，可以说，有了更高版本的编译器，许多条款使用C++98解决问题的思路和方式都显得有些冗余了，我会在每一条款的总结中直接指出在更高版本C++下的解决方案，个人看来，书中提出的解决问题的方法就可以淘汰了，这些地方包括但不限于`final, override, shared_ptr, = delete`。
2. 翻译僵硬。这并不能怪侯捷，因为面对一个大师的作品，我们肯定要在保留语言的原汁原味和尽量符合各国读者的语言风格面前摇摆取舍，但这也造成了相当英文的表达出现在了文中，比如“在这个故事结束之前”，“那就进入某某某变奏曲了”，让不太熟悉英文的读者感到莫名其妙——”变奏曲在哪？“。说实在话，就是知道英文原文的我读起这样的翻译也觉得怪怪的。因此在我的总结中，面对各种因果关系我会把舌头捋直了说，毕竟我不是大师，只注重效率就可以了。
3. 作者的行文之风让读者必须以读一本小说的心态去拜读这部著作。在了解每一个条款时，作者精心准备了各种玩笑、名人名言、典故以及例子，尽量让你感觉不到教科书般的迂腐之气，也用了俏皮的语言使授课不那么僵硬（尽管上述翻译还是让它僵硬了起来）。但对于第二甚至是第三次读这本书的我来说，我更希望这本书像一本**工具书**。例如某条款解决了一个问题，在第一遍读的时候我重点去体会**解决问题的方法是什么**，第二遍我可能更想知道这种问题在什么情况下可能会发生——**什么时候去用**，这是我最关心的。不幸的是，出现这一问题的三个场景可能分布在这个条款的角角落落，我必须重新去读一遍那些已经不好笑的笑话、已经不经典的典故，才能把他们整理好。所以，这篇博文替我把上述我在翻阅时更care的内容总结起来，争取两分钟可以把一个条款的纲要回忆起来，这便是这个博文的目的。

最后，再次向Meyers和侯捷大师致敬。

## 四、设计与声明

### 条款18：让接口容易被正确使用，不易误使用

本条款讨论如何设计接口。

在设计接口时，我们常常会错误地假设，接口的调用者拥有某些必要的知识来规避一些常识性的错误。但事实上，接口的调用者并不总是像正在设计接口的我们一样“聪明”或者知道接口实现的”内幕信息“，结果就是，我们错误的假设使接口表现得不稳定。这些不稳定因素可能是由于调用者缺乏某些先验知识，也有可能仅仅是代码上的粗心错误。接口的调用者可能是别人，也可能是未来的你。所以一个合理的接口，应该尽可能的从**语法层面**并在**编译之时**，帮助接口的调用者规避可能的风险。

* 使用外覆类型提醒调用者传参错误检查，将参数的附加条件限制在类型本身

当调用者试图传入数字“13”来表达一个“月份”的时候，你可以在函数内部做运行期的检查，然后提出报警或一个异常，但这样的做法更像是一种责任转嫁——调用者只有在尝试过后才发现自己手残把“12”写成了“13”。如果在设计参数类型时就把“月份”这一类型抽象出来，比如使用enum class。

* 从语法层面限制调用者**不能做的事**

接口的调用者往往无意或甚至没有意识到自己犯了个错误，所以接口的设计者和实现着必须考虑到并在语法层面做出限制。一个比较常见的限制是加上const，比如在operate*的返回类型上加上const修饰，可以防止无意错误的赋值`if (a * b = c)`。

* 接口应表现出与内置类型的一致性

让自己的类型和内置类型的一致性，比如自定义容器的接口在命名上和STL应具备一致性，可以有效防止调用者犯错误。

* 从语法层面限制调用者**必须做的事**

别让接口的调用者总是记得做某些事情，接口的设计者应在假定他们总是忘记这些条条框框的前提下设计接口。比如用智能指针代替原生指针就是为调用者着想的好例子。如果一个核心方法需要在使用前后设置和恢复环境（比如获取锁和归还锁），更好的做法是将设置和恢复环境设置成抽象函数并要求调用者继承该抽象类，强制他们去实现，而在核心方法前后对设置和恢复环境的调用，则应由方法设计者操心。

当方法的调用者责任越少，他们可能犯的错误也就越少。

### 条款19：设计class犹如设计type

本条款讨论设计class需要注意的细节，但并没有给每一个细节提出解决方案，不过class的设计确实需要case by case的分析，所以每次设计class时最好在脑中过一遍以下问题。

* 对象该如何创建销毁：包括构造函数、析构函数以及new和delete操作符的重构需求。
* 对象的构造函数与赋值行为应有何区别：构造函数和复制操作符的区别。
* 对象被拷贝时应考虑的行为：拷贝构造函数。
* 对象的合法值是什么？最好以语法层面、至少在编译前应对用户做出监督。
* 新的类型是否应该复合某个继承体系，这就包含虚函数的覆盖问题。
* 新类型和已有类型之间的隐式转换问题，这意味着类型转换函数和非explicit函数之间的取舍。
* 新类型是否需要重载操作符。
* 什么样的接口应当暴露在外，而什么样的技术应当封装在内（public和private）
* 新类型的效率、资源获取归还、线程安全性和异常安全性如何保证。
* 这个类是否具备template的潜质，如果有的话，就改为类模板。



### 条款20：宁以pass-by-reference-to-const替换pass-by-value

函数接口应该以const引用的形式传参，而不应该是按值传参，否则可能会有以下问题：

* 按值传参涉及大量参数的复制，这些副本大多是没有必要的。
* 如果拷贝构造函数设计的是深拷贝而非浅拷贝，那么拷贝的成本将远远大于拷贝某几个指针。
* 对于多态而言，将父类设计成按值传参，如果传入的是子类对象，仅会对子类对象的父类部分进行拷贝，即部分拷贝，而所有属于子类的特性将被丢弃，造成不可预知的错误，同时虚函数也不会被调用。
* 小的类型并不意味着按值传参的成本就会小。首先，类型的大小与编译器的类型和版本有很大关系，某些类型在特定编译器上编译结果会比其他编译器大得多。小的类型也无法保证在日后代码复用和重构之后，其类型始终很小。

尽管如此，面对内置类型和STL的迭代器与函数对象，我们通常还是会选择按值传参的方式设计接口。

### 条款22：将成员变量声明为private



## 六、继承与面对对象设计

在设计一个与继承有关的类时，有很多事情需要提前考虑：

* 什么类型的继承？
* 接口是虚函数还是非虚的？
* 缺省参数如何设计？

想要得到以上问题的合理答案，需要考虑的事情就更多了：各种类型的继承到底意味着什么？虚函数的本质需求是什么？继承会影响名称查找吗？虚函数是否是必须的呢？有哪些替代选择？这些问题都在本章做出解答。

### 条款32：确定你的public继承保证了is-a关系

public继承的意思是：__子类是一种特殊的父类__，这就是所谓的“is-a”关系。但是本条款指出了其更深层次的意义：在使用public继承时，__子类必须涵盖父类的所有特点，必须无条件继承父类的所有特性和接口__。之所以单独指出这一点，是因为如果单纯偏信生活经验，会犯错误。

比如鸵鸟是不是鸟这个问题，如果我们考虑飞行这一特性（或接口），那么鸵鸟类在继承中就绝对不能用public继承鸟类，因为鸵鸟不会飞，我们要在**编译阶段消除调用飞行接口的可能性**；但如果我们关心的接口是下蛋的话，按照我们的法则，鸵鸟类就可以public继承鸟类。同样的道理，面对矩形和正方形，生活经验告诉我们正方形是特殊的矩形，但这并不意味着在代码中二者可以存在public的继承关系，矩形具有长和宽两个变量，但正方形无法拥有这两个变量——没有语法层面可以保证二者永远相等，那就不要用public继承。

所以在确定是否需要public继承的时候，我们首先要搞清楚**子类是否必须拥有父类每一个特性**，如果不是，则无论生活经验是什么，都不能视作"is-a"的关系。__public继承关系不会使父类的特性或接口在子类中退化，只会使其扩充。__

### 条款33：避免遮掩继承而来的名称

这个条款研究的是继承中多次重载的虚函数的**名称遮盖问题**，如果在你设计的类中没有涉及到对同名虚函数做多次重载，请忽略本条款。

在父类中，虚函数`foo()`被重载了两次，可能是由于参数类型重载（`foo(int)`），也可能是由于`const`属性重载(`foo() const`)。如果子类仅对父类中的`foo()`进行了覆写，那么在子类中父类的另外两个实现(`foo(int)` ,`foo() const`)也无法被调用，这就是名称遮盖问题——名称在**作用域级别的遮盖是和参数类型以及是否虚函数无关的**，即使子类重载了父类的一个同名，父类的所有同名函数在子类中都被遮盖，个人觉得是比较反直觉的一点。

如果想要重启父类中的函数名称，需要在子类有此需求的作用域中（可能是某成员函数中，可能是public 或private内）加上`using Base::foo;`，即可把父类作用域汇总的同名函数拉到目标作用域中，需要注意的是，此时父类中的`foo(int)`和`foo() const`都会被置为可用。

如果只想把父类某个在子类中某一个已经不可见的同名函数复用，可使用inline forwarding function。

### 条款34：区分接口继承和实现继承

我们在条款32讨论了public继承的实际意义，我们在本条款将明确在public继承体系中，不同类型的接口——纯虚函数、虚函数和非虚函数——**背后隐藏的设计逻辑**。

首先需要明确的是，成员函数的接口总是会被继承，而public继承保证了，如果某个函数可施加在父类上，那么他一定能够被施加在子类上。不同类型的函数代表了**父类对子类实现过程中不同的期望**。

* 在父类中声明纯虚函数，是为了**强制子类拥有一个接口**，并**强制子类提供一份实现**。
* 在父类中声明虚函数，是为了**强制子类拥有一个接口**，并**为其提供一份缺省实现**。
* 在父类中声明非虚函数，是为了**强制子类拥有一个接口以及规定好的实现**，并不允许子类对其做任何更改（条款36要求我们不得覆写父类的非虚函数）。

在这其中，有可能出现问题的是普通虚函数，这是因为父类的缺省实现并不能保证对所有子类都适用，因而当子类忘记实现某个本应有定制版本的虚函数时，父类应从__代码层面提醒子类的设计者做相应的检查__，很可惜，普通虚函数无法实现这个功能。一种解决方案是，在父类中**为纯虚函数提供一份实现**，作为需要主动获取的缺省实现，当子类在实现纯虚函数时，检查后明确缺省实现可以复用，则只需调用该缺省实现即可，这个主动调用过程就是在代码层面提醒子类设计者去检查缺省实现的适用性。

从这里我们可以看出，将纯虚函数、虚函数区分开的并不是在父类有没有实现——纯虚函数也可以有实现，其二者本质区别在于父类对子类的要求不同，前者在于**从编译层面提醒子类主动实现接口**，后者则侧重于**给予子类自由度对接口做个性化适配**。非虚函数则没有给予子类任何自由度，而是要求子类坚定的遵循父类的意志，**保证所有继承体系内能有其一份实现**。

### 条款35：考虑virtual函数以外的其他选择



### 条款36：绝不重新定义继承而来的non-virtual函数

意思就是，如果你的函数有多态调用的需求，一定记得把它设为虚函数，否则在动态调用（基类指针指向子类对象）的时候是不会调用到子类重载过的函数的，很可能会出错。

反之同理，如果一个函数父类没有设置为虚函数，你千万千万不要在子类重载它，也会犯上边类似的错误。

理由就是，多态的动态调用中，只有虚函数是动态绑定，非虚函数是静态绑定的——指针（或引用）的静态类型是什么，就调用那个类型的函数，和动态类型无关。

话说回来，虚函数的意思是“__接口一定被继承，但实现可以在子类更改__”，而非虚函数的意思是“__接口和实现都必须被继承__”，这就是“虚”的实际意义。

### 条款37：绝不重新定义继承而来的缺省参数值

这个条款包含双重意义，在继承中：

1. 不要更改父类非虚函数的缺省参数值，其实**不要重载父类非虚函数的任何东西**，不要做任何改变！
2. 虚函数不要写缺省参数值，子类自然也不要改，**虚函数要从始至终保持没有缺省参数值**。

第一条在条款36解释过了，第二条的原因在于，缺省参数值是属于__静态绑定__的，而虚函数属于动态绑定。虚函数在大多数情况是供动态调用，而在动态调用中，子类做出的缺省参数改变其实并没有生效，反而会引起误会，让调用者误以为生效了。

缺省参数值属于静态绑定的原因是为了提高运行时效率。

如果你真的想让某一个虚函数在这个类中拥有缺省参数，那么就把这个虚函数设置成private，在public接口中重制非虚函数，让非虚函数这个“外壳”拥有缺省参数值，当然，这个外壳也是一次性的——在被继承后不要被重载。

### 条款38：通过复合塑膜出has-a关系，或“根据某物实现出”

两个类的关系除了继承之外，还有“一个类的对象可以作为另一个类的成员”，我们称这种关系为“类的复合”，这个条款解释什么情况下我们应该用类的复合。

第一种情况，非常简单，说明某一个类“拥有”另一个类对象作为一个属性，比如学生拥有铅笔、市民拥有身份证等，不会出错。

第二种情况被讨论的更多，即“一个类根据另一个类实现”。比如“用stack实现一个queue”，更复杂一点的情况可能是“用一个老版本的Google Chrome内核去实现一个红芯浏览器”。

这里重点需要区分第二种情形和public继承中提到的"is-a"的关系。请牢记“is-a”关系的唯一判断法则，一个类的全部属性和接口是否必须**全部**继承到另一个类当中？另一方面，“用一个工具类去实现另一个类”这种情况，是需要对工具类进行**隐藏**的，比如人们并不关心你使用stack实现的queue，所以就藏好所有stack的接口，只把queue的接口提供给人们用就好了，而红芯浏览器的开发者自然也不希望人们发现Google Chrome的内核作为底层实现工具，也需要“藏起来”的行为。

### 条款39：明智而审慎地使用private继承

与类的复合关系相似，private继承正是表达“__通过某工具类实现另一个类__”。那么相似的，工具类在目标类中自然应该被隐藏——所有接口和变量都不应对外暴露出来。这也解释了private继承的内涵，它本质是一种__技术封装__，和public继承不同的是，private继承表达的是“__只有实现部分被继承，而接口部分应略去__”的思想。

与private继承的内涵相对应，在private继承下，__父类的所有成员都转为子类私有变量__——不提供对外访问的权限，外界也无需关心子类内有关父类的任何细节。

当我们拥有“用一个类去实现另一个类”的需求的时候，如何在类的复合与private继承中做选择呢？

* 尽可能用复合，除非必要，不要采用private继承。
* 当我们需要对工具类的某些方法（虚函数）做重载时，我们应选择private继承，这些方法一般都是工具类内专门为继承而设计的调用或回调接口，需要用户自行定制实现。

如果使用private继承，我们无法防止当前子类覆写后的虚函数被它的子类继续覆写，这种要求类似于对__某个接口（函数）加上关键字final一样__。为了实现对目标类的方法的防覆写保护，我们的做法是，在目标类中声明一私有嵌套类，该嵌套类public继承工具类，并在嵌套类的实现中覆写工具类的方法。

~~~C++
class TargetClass {							//目标类
private:
		class ToolHelperClass : public ToolClass {		//嵌套类，public继承工具类
    public:
        void someMethod() override;								//本应被目标类覆写的方法在嵌套类中实现，这样TargetClass的子类就无法覆写该方法。
    }  
}
~~~

如此一来，目标类的子类就无法再次覆写我们想要保护的核心方法。

### 条款40：明智而审慎地使用多继承

原则上不提倡使用多继承，因为多继承可能会引起多父类共用父类，导致在底层子类中出现多余一份的共同祖先类的拷贝。为了避免这个问题C++引入了**虚继承**，但是虚继承会使子类对象变大，同时使成员数据访问速度变慢，这些都是虚继承应该付出的代价。

在不得不使用多继承时，请慎重地设计类别，尽量不要出现菱形多重继承结构（“B、C类继承自A类，D类又继承自B、C类”），即尽可能地避免虚继承，一个完好的多继承结构不应在事后被修改。虚基类中应尽可能避免存放数据。