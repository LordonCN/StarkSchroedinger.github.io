---
layout:     post
title:      "多线程"
subtitle:   "C++学习笔记 六"
date:       2020-02-29
author:     "Felix Zhang"
header-img: "img/in-post/2020-02-29-Multithread/bg.jpg"
catalog: true
tags:
   - C++
   - Multithread



---

# C++与多线程

### 线程的基本概念、线程的基本状态及状态之间的关系？

线程，有时称为轻量级进程，是**CPU使用的基本单元**；它由线程ID、程序计数器、寄存器集合和堆栈组成。它与属于同一进程的其他线程共享其代码段、数据段和其他操作系统资源（如打开文件和信号）。

### 多线程同步和互斥有何异同，在什么情况下分别使用他们？举例说明。

**线程同步**是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。**线程互斥**是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。

### 临界区、互斥量、信号量与事件的区别

四种控制线程的同步与互斥的方法：

1. 临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
2. 互斥量:为协调共同对一个共享资源的单独访问而设计的。 
3. 信号量:为控制一个具有有限数量用户资源而设计。 
4. 事件:用来通知线程有一些事件已发生，从而启动后继任务的开始。 

**临界区**（Critical Section）

保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线 程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。 

**互斥量**（Mutex） 

互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程 所访问。**当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。**互斥量比临界区复杂。因为使用互斥不仅仅能够在同 一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。 

**信号量**（Semaphores）

信号量对象对线程的同步方式与前面几种方法不同，**信号允许多个线程同时使用共享资源**，这与操作系统中的PV操作相同。它指出了同时访问**共享资源的线程最大数目**。它允许多个线程在同一时刻访问同一资源，但是需要**限制**在同一时刻访问此资源的**最大线程数目**。在用CreateSemaphore（）创建信号量 时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数 就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目， 不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore（）函数将当前可 用资源计数加1。在任何时候当前可用资源计数决不可能大于最大资源计数。 

PV操作及信号量的概念都是由荷兰科学家E.W.Dijkstra提出的。信号量S是一个整数，S大于等于零时代表可供并发进程使用的资源实体数，但S小于零时则表示正在等待使用共享资源的进程数。 

P操作 申请资源： 

* S减1； 
* 若S减1后仍大于等于零，则进程继续执行； 
* 若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转入进程调度。 

V操作 释放资源： 

* S加1； 
* 若相加结果大于零，则进程继续执行； 
* 若相加结果小于等于零，则从该信号的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转入进程调度。 

**事件**（Event） 

事件对象也可以通过通知操作的方式来**保持线程的同步**；并且可以实现**不同进程中的线程同步操作**。 总结： 

1. 互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使 用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。 
2. 互斥量（Mutex），信号灯（Semaphore），事件（Event）都可以被跨越进程使用来进行同步数据操作，而其他的对象与数据同步操作无关，但 对于进程和线程来讲，如果进程和线程在运行状态则为无信号状态，在退出后为有信号状态。所以可以使用WaitForSingleObject来等待进程和 线程退出。 
3. 通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根 据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号灯对象可以说是一种资源计数器。
4. 线程间的同步方法大体可分为两类：**用户模式和内核模式**。顾名思义，内核模式就是指利用系统**内核对象的单一性**来进行同步，使用时需要**切换内核态与用户态**，而用户模式就是不需要切换到内核态，只在用户态完成操作。
   用户模式下的方法有：**原子操作**（例如一个单一的全局变量），**临界区**。内核模式下的方法有：事件，信号量，互斥量。

### 线程与进程的区别？

1. 线程是进程的一部分，所以线程有的时候被称为是轻权进程或者轻量级进程，在多线程中堆是共有的而栈是私有的；不同进程中堆也是私有的。
2. 一个没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个进程，进程的执行过程不是一条线（线程）的，而是多条线（线程）共同完成的。
3.  系统在运行的时候会**为每个进程分配不同的内存区域**，但是不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能**共享资源**。那就是说，除了CPU之外（线程在运行的时候要占用CPU资源），**计算机内部的软硬件资源的分配与线程无关**，线程只能共享它所属进程的资源。
4.  与进程的控制表PCB相似，线程也有自己的控制表TCB，但是TCB中所保存的线程状态比PCB表中少多了。
5.  **进程是系统所有资源分配时候的一个基本单位**，拥有一个完整的虚拟空间地址，并不依赖线程而独立存在。

### 多线程有几种实现方法，都是什么？

* 继承 Thread 类
* 实现 Runnable 接口再 new Thread(YourRunnableOjbect) 

